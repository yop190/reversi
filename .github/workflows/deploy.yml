# ============================================
# Reversi - CI/CD Pipeline
# Deploys Frontend + Backend to Azure Container Apps
# ============================================

name: Build and Deploy to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  # Azure Configuration
  AZURE_RESOURCE_GROUP: rg-reversi-prod
  AZURE_LOCATION: westeurope
  AZURE_CONTAINER_REGISTRY: acrreversiprod
  AZURE_CONTAINER_APP_ENV: cae-reversi-prod
  
  # Container Apps
  AZURE_CONTAINER_APP_FRONTEND: ca-reversi
  AZURE_CONTAINER_APP_BACKEND: ca-reversi-backend
  
  # Image Configuration
  IMAGE_NAME_FRONTEND: reversi-frontend
  IMAGE_NAME_BACKEND: reversi-backend
  
  # Custom Domain
  CUSTOM_DOMAIN: reversi.lebrere.fr

jobs:
  # ==========================================
  # Job 1: Build and Test
  # ==========================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Run frontend tests
        run: npm run test -- --watch=false --browsers=ChromeHeadless

      - name: Build frontend
        run: npm run build -- --configuration production

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

  # ==========================================
  # Job 2: Build and Push Docker Images
  # ==========================================
  build-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Provision Azure Infrastructure
        run: |
          echo "üîß Provisioning Azure Infrastructure..."
          
          # Register required providers (idempotent)
          echo "üìã Registering Azure providers..."
          az provider register -n Microsoft.OperationalInsights --wait || true
          az provider register -n Microsoft.App --wait || true
          
          # Create Resource Group
          echo "üì¶ Creating Resource Group..."
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }} \
            --output none
          
          # Create Container Registry
          echo "üì¶ Creating Container Registry..."
          az acr create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_REGISTRY }} \
            --sku Basic \
            --admin-enabled true \
            --output none 2>/dev/null || echo "ACR already exists"
          
          # Create Container Apps Environment
          echo "üì¶ Creating Container Apps Environment..."
          az containerapp env create \
            --name ${{ env.AZURE_CONTAINER_APP_ENV }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }} \
            --output none 2>/dev/null || echo "Container Apps Environment already exists"
          
          # Wait for environment to be ready
          echo "‚è≥ Waiting for environment to be ready..."
          for i in {1..30}; do
            STATE=$(az containerapp env show \
              --name ${{ env.AZURE_CONTAINER_APP_ENV }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --query "properties.provisioningState" -o tsv 2>/dev/null || echo "NotFound")
            if [ "$STATE" = "Succeeded" ]; then
              echo "‚úÖ Environment is ready"
              break
            fi
            echo "  State: $STATE - waiting..."
            sleep 10
          done
          
          echo "‚úÖ Infrastructure provisioned"

      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ env.AZURE_CONTAINER_REGISTRY }}

      - name: Build and push Backend Docker image
        run: |
          BACKEND_TAG="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}"
          BACKEND_LATEST="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_BACKEND }}:latest"
          
          echo "üê≥ Building Backend Docker image..."
          docker build -f backend/Dockerfile -t $BACKEND_TAG -t $BACKEND_LATEST .
          
          echo "üì§ Pushing Backend to ACR..."
          docker push $BACKEND_TAG
          docker push $BACKEND_LATEST
          
          echo "BACKEND_IMAGE_TAG=$BACKEND_TAG" >> $GITHUB_ENV

      - name: Deploy Backend Container App
        id: deploy-backend
        run: |
          echo "üöÄ Deploying Backend Container App..."
          
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "passwords[0].value" -o tsv)
          
          # Check if Backend Container App exists
          if az containerapp show --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Backend Container App exists, updating..."
            az containerapp update \
              --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --image ${{ env.BACKEND_IMAGE_TAG }} \
              --output none
          else
            echo "üì¶ Creating new Backend Container App..."
            az containerapp create \
              --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --environment ${{ env.AZURE_CONTAINER_APP_ENV }} \
              --image ${{ env.BACKEND_IMAGE_TAG }} \
              --target-port 3001 \
              --ingress external \
              --registry-server ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io \
              --registry-username $ACR_USERNAME \
              --registry-password $ACR_PASSWORD \
              --min-replicas 1 \
              --max-replicas 5 \
              --cpu 0.25 \
              --memory 0.5Gi \
              --output none
          fi
          
          # Get Backend FQDN
          BACKEND_FQDN=$(az containerapp show \
            --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          echo "‚úÖ Backend deployed at: https://$BACKEND_FQDN"
          echo "fqdn=$BACKEND_FQDN" >> $GITHUB_OUTPUT
          echo "BACKEND_FQDN=$BACKEND_FQDN" >> $GITHUB_ENV

      - name: Wait for Backend to be ready
        run: |
          echo "‚è≥ Waiting for Backend to be ready..."
          for i in {1..20}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.BACKEND_FQDN }}/health" --max-time 10 || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Backend is healthy!"
              curl -s "https://${{ env.BACKEND_FQDN }}/health"
              break
            fi
            echo "  Attempt $i: Status $RESPONSE - waiting..."
            sleep 10
          done

      - name: Update Frontend environment with Backend URL
        run: |
          # Update production environment file with actual backend URL
          cat > src/environments/environment.prod.ts << EOF
          /**
           * Production environment configuration
           * Backend URL is set to the Azure Container App
           */
          export const environment = {
            production: true,
            backendUrl: 'https://${{ env.BACKEND_FQDN }}',
            wsUrl: 'https://${{ env.BACKEND_FQDN }}',
          };
          EOF
          
          echo "üìù Updated environment.prod.ts with backend URL: https://${{ env.BACKEND_FQDN }}"
          cat src/environments/environment.prod.ts

      - name: Build and push Frontend Docker image
        run: |
          FRONTEND_TAG="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}"
          FRONTEND_LATEST="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_FRONTEND }}:latest"
          
          echo "üê≥ Building Frontend Docker image..."
          docker build -t $FRONTEND_TAG -t $FRONTEND_LATEST .
          
          echo "üì§ Pushing Frontend to ACR..."
          docker push $FRONTEND_TAG
          docker push $FRONTEND_LATEST
          
          echo "FRONTEND_IMAGE_TAG=$FRONTEND_TAG" >> $GITHUB_ENV

  # ==========================================
  # Job 3: Deploy Frontend to Azure Container Apps
  # ==========================================
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: build-images
    environment:
      name: production
      url: https://${{ env.CUSTOM_DOMAIN }}
    
    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy Frontend Container App
        run: |
          FRONTEND_TAG="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}"
          
          echo "üöÄ Deploying Frontend Container App..."
          
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "passwords[0].value" -o tsv)
          
          # Check if Frontend Container App exists
          if az containerapp show --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Frontend Container App exists, updating..."
            az containerapp update \
              --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --image $FRONTEND_TAG \
              --output none
          else
            echo "üì¶ Creating new Frontend Container App..."
            az containerapp create \
              --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --environment ${{ env.AZURE_CONTAINER_APP_ENV }} \
              --image $FRONTEND_TAG \
              --target-port 80 \
              --ingress external \
              --registry-server ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io \
              --registry-username $ACR_USERNAME \
              --registry-password $ACR_PASSWORD \
              --min-replicas 1 \
              --max-replicas 10 \
              --cpu 0.25 \
              --memory 0.5Gi \
              --output none
          fi
          
          # Get Frontend FQDN
          FRONTEND_FQDN=$(az containerapp show \
            --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          echo "‚úÖ Frontend deployed at: https://$FRONTEND_FQDN"
          echo "FRONTEND_FQDN=$FRONTEND_FQDN" >> $GITHUB_ENV

      - name: Configure Custom Domain
        run: |
          echo "üåê Configuring custom domain: ${{ env.CUSTOM_DOMAIN }}"
          
          # Add custom domain (requires DNS to be configured)
          az containerapp hostname add \
            --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --hostname ${{ env.CUSTOM_DOMAIN }} \
            --output none 2>/dev/null || echo "Domain may already be configured"
          
          # Bind managed certificate
          az containerapp hostname bind \
            --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --hostname ${{ env.CUSTOM_DOMAIN }} \
            --environment ${{ env.AZURE_CONTAINER_APP_ENV }} \
            --validation-method CNAME \
            --output none 2>/dev/null || echo "Certificate may already exist"
          
          echo "‚úÖ Custom domain configuration complete"

      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for deployment to stabilize..."
          sleep 30

  # ==========================================
  # Job 4: Verify Deployment & Multiplayer
  # ==========================================
  verify-deployment:
    name: Verify Deployment & Multiplayer
    runs-on: ubuntu-latest
    needs: [build-images, deploy-frontend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify Frontend Health
        run: |
          echo "üîç Verifying Frontend health..."
          
          for i in {1..10}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.CUSTOM_DOMAIN }}/health" --max-time 15 || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Frontend health check passed!"
              curl -s "https://${{ env.CUSTOM_DOMAIN }}/health"
              echo ""
              break
            fi
            echo "Attempt $i: Status $RESPONSE - waiting..."
            sleep 10
          done
          
          if [ "$RESPONSE" != "200" ]; then
            echo "‚ùå Frontend health check failed!"
            exit 1
          fi

      - name: Get Backend URL
        id: backend-url
        run: |
          BACKEND_FQDN=$(az containerapp show \
            --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          echo "BACKEND_FQDN=$BACKEND_FQDN" >> $GITHUB_ENV
          echo "Backend URL: https://$BACKEND_FQDN"

      - name: Verify Backend Health
        run: |
          echo "üîç Verifying Backend health..."
          
          for i in {1..10}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.BACKEND_FQDN }}/health" --max-time 15 || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Backend health check passed!"
              curl -s "https://${{ env.BACKEND_FQDN }}/health"
              echo ""
              break
            fi
            echo "Attempt $i: Status $RESPONSE - waiting..."
            sleep 10
          done
          
          if [ "$RESPONSE" != "200" ]; then
            echo "‚ùå Backend health check failed!"
            exit 1
          fi

      - name: Install Socket.IO Client for Testing
        run: |
          npm install socket.io-client

      - name: Test WebSocket Multiplayer Connectivity
        run: |
          echo "üéÆ Testing WebSocket multiplayer connectivity..."
          
          cat > test-websocket.js << 'EOF'
          const { io } = require('socket.io-client');
          
          const BACKEND_URL = process.env.BACKEND_URL;
          const TIMEOUT = 30000; // 30 seconds
          
          console.log(`Connecting to: ${BACKEND_URL}`);
          
          const socket = io(BACKEND_URL, {
            transports: ['websocket', 'polling'],
            timeout: TIMEOUT,
            reconnection: false,
          });
          
          let connected = false;
          let roomCreated = false;
          
          const timeoutId = setTimeout(() => {
            console.error('‚ùå Connection timeout - multiplayer is not working!');
            process.exit(1);
          }, TIMEOUT);
          
          socket.on('connect', () => {
            console.log('‚úÖ WebSocket connected!');
            connected = true;
          });
          
          socket.on('connected', (data) => {
            console.log('‚úÖ Received player info:', JSON.stringify(data));
            
            // Try to create a room
            console.log('üìù Creating a test room...');
            socket.emit('createRoom', { roomName: 'CI-Test-Room' });
          });
          
          socket.on('roomJoined', (data) => {
            console.log('‚úÖ Room created/joined successfully!', JSON.stringify(data));
            roomCreated = true;
            
            // Leave the room and disconnect
            socket.emit('leaveRoom');
            
            setTimeout(() => {
              clearTimeout(timeoutId);
              console.log('');
              console.log('‚úÖ‚úÖ‚úÖ MULTIPLAYER CONNECTIVITY TEST PASSED ‚úÖ‚úÖ‚úÖ');
              console.log('');
              socket.disconnect();
              process.exit(0);
            }, 1000);
          });
          
          socket.on('lobbyUpdate', (data) => {
            console.log('üìä Lobby update received:', JSON.stringify(data));
          });
          
          socket.on('error', (error) => {
            console.log('‚ö†Ô∏è Server error:', JSON.stringify(error));
          });
          
          socket.on('connect_error', (error) => {
            console.error('‚ùå Connection error:', error.message);
            clearTimeout(timeoutId);
            process.exit(1);
          });
          
          socket.on('disconnect', (reason) => {
            console.log('Disconnected:', reason);
            if (!roomCreated) {
              clearTimeout(timeoutId);
              process.exit(1);
            }
          });
          EOF
          
          BACKEND_URL="https://${{ env.BACKEND_FQDN }}" node test-websocket.js

      - name: Deployment Summary
        run: |
          echo ""
          echo "========================================"
          echo "üéâ DEPLOYMENT COMPLETE & VERIFIED"
          echo "========================================"
          echo ""
          echo "üìç Frontend: https://${{ env.CUSTOM_DOMAIN }}"
          echo "üìç Backend:  https://${{ env.BACKEND_FQDN }}"
          echo ""
          echo "‚úÖ Frontend health: OK"
          echo "‚úÖ Backend health: OK"
          echo "‚úÖ WebSocket connectivity: OK"
          echo "‚úÖ Multiplayer rooms: OK"
          echo ""
          echo "üéÆ Multiplayer is fully operational!"
          echo "========================================"
