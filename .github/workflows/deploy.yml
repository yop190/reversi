# ============================================
# Reversi - CI/CD Pipeline
# Deploys Frontend + Backend to Azure Container Apps
# Requires Security Gate to pass before deployment
# ============================================

name: Build and Deploy to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  # Azure Configuration
  AZURE_RESOURCE_GROUP: rg-reversi-prod
  AZURE_LOCATION: westeurope
  AZURE_CONTAINER_REGISTRY: acrreversiprod
  AZURE_CONTAINER_APP_ENV: cae-reversi-prod
  
  # Azure Key Vault
  AZURE_KEY_VAULT_NAME: kv-reversi-prod
  
  # Container Apps
  AZURE_CONTAINER_APP_FRONTEND: ca-reversi
  AZURE_CONTAINER_APP_BACKEND: ca-reversi-backend
  
  # Image Configuration
  IMAGE_NAME_FRONTEND: reversi-frontend
  IMAGE_NAME_BACKEND: reversi-backend
  
  # Custom Domain
  CUSTOM_DOMAIN: reversi.lebrere.fr

jobs:
  # ==========================================
  # Job 0: Security Gate Check
  # ==========================================
  security-check:
    name: Security Gate Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Run Security Scans
        run: |
          echo "üîê Running security checks..."
          
          # Install dependencies
          npm ci
          cd backend && npm ci && cd ..
          
          # Run npm audit for both frontend and backend
          echo "üì¶ Checking frontend dependencies..."
          npm audit --audit-level=high || {
            echo "‚ùå SECURITY GATE FAILED: High vulnerabilities in frontend"
            exit 1
          }
          
          echo "üì¶ Checking backend dependencies..."
          cd backend
          npm audit --audit-level=high || {
            echo "‚ùå SECURITY GATE FAILED: High vulnerabilities in backend"
            exit 1
          }
          cd ..
          
          echo "‚úÖ Security checks passed"

  # ==========================================
  # Job 1: Build and Test
  # ==========================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: security-check
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Run frontend tests
        run: npm run test -- --watch=false --browsers=ChromeHeadless

      - name: Build frontend
        run: npm run build -- --configuration production

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

  # ==========================================
  # Job 2: Build and Push Docker Images
  # ==========================================
  build-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Provision Azure Infrastructure
        run: |
          echo "üîß Provisioning Azure Infrastructure..."
          
          # Register required providers (idempotent)
          echo "üìã Registering Azure providers..."
          az provider register -n Microsoft.OperationalInsights --wait || true
          az provider register -n Microsoft.App --wait || true
          
          # Create Resource Group
          echo "üì¶ Creating Resource Group..."
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }} \
            --output none
          
          # Create Container Registry
          echo "üì¶ Creating Container Registry..."
          az acr create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_REGISTRY }} \
            --sku Basic \
            --admin-enabled true \
            --output none 2>/dev/null || echo "ACR already exists"
          
          # Create Container Apps Environment
          echo "üì¶ Creating Container Apps Environment..."
          az containerapp env create \
            --name ${{ env.AZURE_CONTAINER_APP_ENV }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }} \
            --output none 2>/dev/null || echo "Container Apps Environment already exists"
          
          # Wait for environment to be ready
          echo "‚è≥ Waiting for environment to be ready..."
          for i in {1..30}; do
            STATE=$(az containerapp env show \
              --name ${{ env.AZURE_CONTAINER_APP_ENV }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --query "properties.provisioningState" -o tsv 2>/dev/null || echo "NotFound")
            if [ "$STATE" = "Succeeded" ]; then
              echo "‚úÖ Environment is ready"
              break
            fi
            echo "  State: $STATE - waiting..."
            sleep 10
          done
          
          # Create Key Vault for secrets
          echo "üîê Creating Azure Key Vault..."
          az keyvault create \
            --name ${{ env.AZURE_KEY_VAULT_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }} \
            --enable-rbac-authorization true \
            --output none 2>/dev/null || echo "Key Vault already exists"
          
          echo "‚úÖ Infrastructure provisioned"

      - name: Fetch Secrets from Azure Key Vault
        id: keyvault-secrets
        run: |
          echo "üîê Fetching secrets from Azure Key Vault..."
          
          # Fetch Google OAuth secrets (use the correct secret name)
          GOOGLE_CLIENT_ID=$(az keyvault secret show \
            --vault-name ${{ env.AZURE_KEY_VAULT_NAME }} \
            --name "google-oauth-client-id" \
            --query "value" -o tsv 2>/dev/null || echo "")
          
          GOOGLE_CLIENT_SECRET=$(az keyvault secret show \
            --vault-name ${{ env.AZURE_KEY_VAULT_NAME }} \
            --name "google-oauth-client-secret" \
            --query "value" -o tsv 2>/dev/null || echo "")
          
          JWT_SECRET=$(az keyvault secret show \
            --vault-name ${{ env.AZURE_KEY_VAULT_NAME }} \
            --name "jwt-secret" \
            --query "value" -o tsv 2>/dev/null || echo "")
          
          AZURE_STORAGE_CONNECTION_STRING=$(az keyvault secret show \
            --vault-name ${{ env.AZURE_KEY_VAULT_NAME }} \
            --name "azure-storage-connection-string" \
            --query "value" -o tsv 2>/dev/null || echo "")
          
          # Set outputs (masked)
          if [ -n "$GOOGLE_CLIENT_ID" ]; then
            echo "::add-mask::$GOOGLE_CLIENT_ID"
            echo "google-client-id=$GOOGLE_CLIENT_ID" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$GOOGLE_CLIENT_SECRET" ]; then
            echo "::add-mask::$GOOGLE_CLIENT_SECRET"
            echo "google-client-secret=$GOOGLE_CLIENT_SECRET" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$JWT_SECRET" ]; then
            echo "::add-mask::$JWT_SECRET"
            echo "jwt-secret=$JWT_SECRET" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$AZURE_STORAGE_CONNECTION_STRING" ]; then
            echo "::add-mask::$AZURE_STORAGE_CONNECTION_STRING"
            echo "azure-storage-connection-string=$AZURE_STORAGE_CONNECTION_STRING" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Secrets fetched from Key Vault"

      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ env.AZURE_CONTAINER_REGISTRY }}

      - name: Build and push Backend Docker image
        run: |
          BACKEND_TAG="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}"
          BACKEND_LATEST="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_BACKEND }}:latest"
          
          echo "üê≥ Building Backend Docker image..."
          docker build -f backend/Dockerfile -t $BACKEND_TAG -t $BACKEND_LATEST .
          
          echo "üì§ Pushing Backend to ACR..."
          docker push $BACKEND_TAG
          docker push $BACKEND_LATEST
          
          echo "BACKEND_IMAGE_TAG=$BACKEND_TAG" >> $GITHUB_ENV

      - name: Deploy Backend Container App
        id: deploy-backend
        run: |
          echo "üöÄ Deploying Backend Container App..."
          
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "passwords[0].value" -o tsv)
          
          # Fetch environment variables from Key Vault
          GOOGLE_CLIENT_ID="${{ steps.keyvault-secrets.outputs.google-client-id }}"
          GOOGLE_CLIENT_SECRET="${{ steps.keyvault-secrets.outputs.google-client-secret }}"
          JWT_SECRET="${{ steps.keyvault-secrets.outputs.jwt-secret }}"
          AZURE_STORAGE_CONNECTION_STRING="${{ steps.keyvault-secrets.outputs.azure-storage-connection-string }}"
          
          # Validate required secrets are present
          if [ -z "$GOOGLE_CLIENT_ID" ]; then
            echo "‚ùå ERROR: GOOGLE_CLIENT_ID not found in Key Vault"
            exit 1
          fi
          
          if [ -z "$GOOGLE_CLIENT_SECRET" ]; then
            echo "‚ùå ERROR: GOOGLE_CLIENT_SECRET not found in Key Vault"
            exit 1
          fi
          
          # Use default JWT secret if not configured
          JWT_SECRET="${JWT_SECRET:-reversi-jwt-secret-change-in-production}"
          
          # Check if Backend Container App exists
          if az containerapp show --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Backend Container App exists, updating..."
            az containerapp update \
              --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --image ${{ env.BACKEND_IMAGE_TAG }} \
              --set-env-vars \
                "GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID" \
                "GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET" \
                "JWT_SECRET=$JWT_SECRET" \
                "AZURE_STORAGE_CONNECTION_STRING=$AZURE_STORAGE_CONNECTION_STRING" \
                "NODE_ENV=production" \
              --output none
          else
            echo "üì¶ Creating new Backend Container App..."
            az containerapp create \
              --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --environment ${{ env.AZURE_CONTAINER_APP_ENV }} \
              --image ${{ env.BACKEND_IMAGE_TAG }} \
              --target-port 3001 \
              --ingress external \
              --registry-server ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io \
              --registry-username $ACR_USERNAME \
              --registry-password $ACR_PASSWORD \
              --env-vars \
                "GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID" \
                "GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET" \
                "JWT_SECRET=$JWT_SECRET" \
                "AZURE_STORAGE_CONNECTION_STRING=$AZURE_STORAGE_CONNECTION_STRING" \
                "NODE_ENV=production" \
              --min-replicas 1 \
              --max-replicas 5 \
              --cpu 0.25 \
              --memory 0.5Gi \
              --output none
          fi
          
          # Get Backend FQDN
          BACKEND_FQDN=$(az containerapp show \
            --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          echo "‚úÖ Backend deployed at: https://$BACKEND_FQDN"
          echo "fqdn=$BACKEND_FQDN" >> $GITHUB_OUTPUT
          echo "BACKEND_FQDN=$BACKEND_FQDN" >> $GITHUB_ENV

      - name: Wait for Backend to be ready
        run: |
          echo "‚è≥ Waiting for Backend to be ready..."
          for i in {1..20}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.BACKEND_FQDN }}/health" --max-time 10 || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Backend is healthy!"
              curl -s "https://${{ env.BACKEND_FQDN }}/health"
              break
            fi
            echo "  Attempt $i: Status $RESPONSE - waiting..."
            sleep 10
          done

      - name: Update Frontend environment with Backend URL
        run: |
          # Update production environment file with actual backend URL
          cat > src/environments/environment.prod.ts << EOF
          /**
           * Production environment configuration
           * Backend URL is set to the Azure Container App
           */
          export const environment = {
            production: true,
            backendUrl: 'https://${{ env.BACKEND_FQDN }}',
            wsUrl: 'https://${{ env.BACKEND_FQDN }}',
          };
          EOF
          
          echo "üìù Updated environment.prod.ts with backend URL: https://${{ env.BACKEND_FQDN }}"
          cat src/environments/environment.prod.ts

      - name: Build and push Frontend Docker image
        run: |
          FRONTEND_TAG="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}"
          FRONTEND_LATEST="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_FRONTEND }}:latest"
          
          echo "üê≥ Building Frontend Docker image..."
          docker build -t $FRONTEND_TAG -t $FRONTEND_LATEST .
          
          echo "üì§ Pushing Frontend to ACR..."
          docker push $FRONTEND_TAG
          docker push $FRONTEND_LATEST
          
          echo "FRONTEND_IMAGE_TAG=$FRONTEND_TAG" >> $GITHUB_ENV

  # ==========================================
  # Job 3: Deploy Frontend to Azure Container Apps
  # ==========================================
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: build-images
    environment:
      name: production
      url: https://${{ env.CUSTOM_DOMAIN }}
    
    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy Frontend Container App
        run: |
          FRONTEND_TAG="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}"
          
          echo "üöÄ Deploying Frontend Container App..."
          
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.AZURE_CONTAINER_REGISTRY }} --query "passwords[0].value" -o tsv)
          
          # Check if Frontend Container App exists
          if az containerapp show --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Frontend Container App exists, updating..."
            az containerapp update \
              --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --image $FRONTEND_TAG \
              --output none
          else
            echo "üì¶ Creating new Frontend Container App..."
            az containerapp create \
              --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --environment ${{ env.AZURE_CONTAINER_APP_ENV }} \
              --image $FRONTEND_TAG \
              --target-port 80 \
              --ingress external \
              --registry-server ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io \
              --registry-username $ACR_USERNAME \
              --registry-password $ACR_PASSWORD \
              --min-replicas 1 \
              --max-replicas 10 \
              --cpu 0.25 \
              --memory 0.5Gi \
              --output none
          fi
          
          # Get Frontend FQDN
          FRONTEND_FQDN=$(az containerapp show \
            --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          echo "‚úÖ Frontend deployed at: https://$FRONTEND_FQDN"
          echo "FRONTEND_FQDN=$FRONTEND_FQDN" >> $GITHUB_ENV

      - name: Configure Custom Domain
        run: |
          echo "üåê Configuring custom domain: ${{ env.CUSTOM_DOMAIN }}"
          
          # Add custom domain (requires DNS to be configured)
          az containerapp hostname add \
            --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --hostname ${{ env.CUSTOM_DOMAIN }} \
            --output none 2>/dev/null || echo "Domain may already be configured"
          
          # Bind managed certificate
          az containerapp hostname bind \
            --name ${{ env.AZURE_CONTAINER_APP_FRONTEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --hostname ${{ env.CUSTOM_DOMAIN }} \
            --environment ${{ env.AZURE_CONTAINER_APP_ENV }} \
            --validation-method CNAME \
            --output none 2>/dev/null || echo "Certificate may already exist"
          
          echo "‚úÖ Custom domain configuration complete"

      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for deployment to stabilize..."
          sleep 30

  # ==========================================
  # Job 4: Verify Deployment & Multiplayer
  # ==========================================
  verify-deployment:
    name: Verify Deployment & Multiplayer
    runs-on: ubuntu-latest
    needs: [build-images, deploy-frontend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify Frontend Health
        run: |
          echo "üîç Verifying Frontend health..."
          
          for i in {1..10}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.CUSTOM_DOMAIN }}/health" --max-time 15 || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Frontend health check passed!"
              curl -s "https://${{ env.CUSTOM_DOMAIN }}/health"
              echo ""
              break
            fi
            echo "Attempt $i: Status $RESPONSE - waiting..."
            sleep 10
          done
          
          if [ "$RESPONSE" != "200" ]; then
            echo "‚ùå Frontend health check failed!"
            exit 1
          fi

      - name: Get Backend URL
        id: backend-url
        run: |
          BACKEND_FQDN=$(az containerapp show \
            --name ${{ env.AZURE_CONTAINER_APP_BACKEND }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          echo "BACKEND_FQDN=$BACKEND_FQDN" >> $GITHUB_ENV
          echo "Backend URL: https://$BACKEND_FQDN"

      - name: Verify Backend Health
        run: |
          echo "üîç Verifying Backend health..."
          
          for i in {1..10}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.BACKEND_FQDN }}/health" --max-time 15 || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Backend health check passed!"
              curl -s "https://${{ env.BACKEND_FQDN }}/health"
              echo ""
              break
            fi
            echo "Attempt $i: Status $RESPONSE - waiting..."
            sleep 10
          done
          
          if [ "$RESPONSE" != "200" ]; then
            echo "‚ùå Backend health check failed!"
            exit 1
          fi

      - name: Install Socket.IO Client for Testing
        run: |
          npm install socket.io-client

      - name: Test WebSocket Multiplayer Connectivity
        run: |
          echo "üéÆ Testing WebSocket multiplayer connectivity..."
          
          cat > test-websocket.js << 'EOF'
          const { io } = require('socket.io-client');
          
          const BACKEND_URL = process.env.BACKEND_URL;
          const TIMEOUT = 30000; // 30 seconds
          
          console.log(`Connecting to: ${BACKEND_URL}`);
          
          const socket = io(BACKEND_URL, {
            transports: ['websocket', 'polling'],
            timeout: TIMEOUT,
            reconnection: false,
          });
          
          let connected = false;
          let roomCreated = false;
          
          const timeoutId = setTimeout(() => {
            console.error('‚ùå Connection timeout - multiplayer is not working!');
            process.exit(1);
          }, TIMEOUT);
          
          socket.on('connect', () => {
            console.log('‚úÖ WebSocket connected!');
            connected = true;
          });
          
          // Events use 'server:' and 'client:' prefixes
          socket.on('server:connected', (data) => {
            console.log('‚úÖ Received player info:', JSON.stringify(data));
            
            // Try to create a room
            console.log('üìù Creating a test room...');
            socket.emit('client:createRoom', { roomName: 'CI-Test-Room' });
          });
          
          socket.on('server:roomJoined', (data) => {
            console.log('‚úÖ Room created/joined successfully!', JSON.stringify(data));
            roomCreated = true;
            
            // Leave the room and disconnect
            socket.emit('client:leaveRoom');
            
            setTimeout(() => {
              clearTimeout(timeoutId);
              console.log('');
              console.log('‚úÖ‚úÖ‚úÖ MULTIPLAYER CONNECTIVITY TEST PASSED ‚úÖ‚úÖ‚úÖ');
              console.log('');
              socket.disconnect();
              process.exit(0);
            }, 1000);
          });
          
          socket.on('server:lobbyUpdate', (data) => {
            console.log('üìä Lobby update received:', JSON.stringify(data));
          });
          
          socket.on('server:error', (error) => {
            console.log('‚ö†Ô∏è Server error:', JSON.stringify(error));
          });
          
          socket.on('connect_error', (error) => {
            console.error('‚ùå Connection error:', error.message);
            clearTimeout(timeoutId);
            process.exit(1);
          });
          
          socket.on('disconnect', (reason) => {
            console.log('Disconnected:', reason);
            if (!roomCreated) {
              clearTimeout(timeoutId);
              process.exit(1);
            }
          });
          EOF
          
          BACKEND_URL="https://${{ env.BACKEND_FQDN }}" node test-websocket.js

      - name: Deployment Summary
        run: |
          echo ""
          echo "========================================"
          echo "üéâ DEPLOYMENT COMPLETE & VERIFIED"
          echo "========================================"
          echo ""
          echo "üìç Frontend: https://${{ env.CUSTOM_DOMAIN }}"
          echo "üìç Backend:  https://${{ env.BACKEND_FQDN }}"
          echo ""
          echo "‚úÖ Frontend health: OK"
          echo "‚úÖ Backend health: OK"
          echo "‚úÖ WebSocket connectivity: OK"
          echo "‚úÖ Multiplayer rooms: OK"
          echo ""
          echo "üéÆ Multiplayer is fully operational!"
          echo "========================================"
